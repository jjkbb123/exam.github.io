"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcopy_password_plugin"] = self["webpackChunkcopy_password_plugin"] || []).push([["defaultVendors-node_modules_use-gesture_core_actions_dist_use-gesture-core-actions_esm_js-nod-a9ca7c"],{

/***/ "./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConfigResolverMap\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   \"EngineMap\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   \"dragAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   \"hoverAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   \"moveAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   \"pinchAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   \"registerAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   \"scrollAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   \"wheelAction\": () => (/* reexport safe */ _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _dist_actions_65020aef_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/actions-65020aef.esm.js */ \"./node_modules/@use-gesture/core/dist/actions-65020aef.esm.js\");\n\n\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js?");

/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/actions-65020aef.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/actions-65020aef.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"C\": () => (/* binding */ ConfigResolverMap),\n/* harmony export */   \"E\": () => (/* binding */ EngineMap),\n/* harmony export */   \"S\": () => (/* binding */ SUPPORT),\n/* harmony export */   \"_\": () => (/* binding */ _objectSpread2),\n/* harmony export */   \"a\": () => (/* binding */ _defineProperty),\n/* harmony export */   \"b\": () => (/* binding */ touchIds),\n/* harmony export */   \"c\": () => (/* binding */ chain),\n/* harmony export */   \"d\": () => (/* binding */ toHandlerProp),\n/* harmony export */   \"e\": () => (/* binding */ dragAction),\n/* harmony export */   \"f\": () => (/* binding */ pinchAction),\n/* harmony export */   \"h\": () => (/* binding */ hoverAction),\n/* harmony export */   \"i\": () => (/* binding */ isTouch),\n/* harmony export */   \"m\": () => (/* binding */ moveAction),\n/* harmony export */   \"p\": () => (/* binding */ parseProp),\n/* harmony export */   \"r\": () => (/* binding */ registerAction),\n/* harmony export */   \"s\": () => (/* binding */ scrollAction),\n/* harmony export */   \"t\": () => (/* binding */ toDomEventType),\n/* harmony export */   \"w\": () => (/* binding */ wheelAction)\n/* harmony export */ });\n/* harmony import */ var _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maths-b2a210f4.esm.js */ \"./node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar EVENT_TYPE_MAP = {\n  pointer: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  mouse: {\n    start: 'down',\n    change: 'move',\n    end: 'up'\n  },\n  touch: {\n    start: 'start',\n    change: 'move',\n    end: 'end'\n  },\n  gesture: {\n    start: 'start',\n    change: 'change',\n    end: 'end'\n  }\n};\n\nfunction capitalize(string) {\n  if (!string) return '';\n  return string[0].toUpperCase() + string.slice(1);\n}\n\nvar actionsWithoutCaptureSupported = ['enter', 'leave'];\n\nfunction hasCapture() {\n  var capture = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var actionKey = arguments.length > 1 ? arguments[1] : undefined;\n  return capture && !actionsWithoutCaptureSupported.includes(actionKey);\n}\n\nfunction toHandlerProp(device) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var deviceProps = EVENT_TYPE_MAP[device];\n  var actionKey = deviceProps ? deviceProps[action] || action : action;\n  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');\n}\n\nvar pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];\n\nfunction parseProp(prop) {\n  var eventKey = prop.substring(2).toLowerCase();\n  var passive = !!~eventKey.indexOf('passive');\n  if (passive) eventKey = eventKey.replace('passive', '');\n  var captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';\n  var capture = !!~eventKey.indexOf(captureKey);\n  if (capture) eventKey = eventKey.replace('capture', '');\n  return {\n    device: eventKey,\n    capture: capture,\n    passive: passive\n  };\n}\n\nfunction toDomEventType(device) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var deviceProps = EVENT_TYPE_MAP[device];\n  var actionKey = deviceProps ? deviceProps[action] || action : action;\n  return device + actionKey;\n}\n\nfunction isTouch(event) {\n  return 'touches' in event;\n}\n\nfunction getPointerType(event) {\n  if (isTouch(event)) return 'touch';\n  if ('pointerType' in event) return event.pointerType;\n  return 'mouse';\n}\n\nfunction getCurrentTargetTouchList(event) {\n  return Array.from(event.touches).filter(function (e) {\n    var _event$currentTarget, _event$currentTarget$;\n\n    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));\n  });\n}\n\nfunction getTouchList(event) {\n  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;\n}\n\nfunction getValueEvent(event) {\n  return isTouch(event) ? getTouchList(event)[0] : event;\n}\n\nfunction distanceAngle(P1, P2) {\n  var dx = P2.clientX - P1.clientX;\n  var dy = P2.clientY - P1.clientY;\n  var cx = (P2.clientX + P1.clientX) / 2;\n  var cy = (P2.clientY + P1.clientY) / 2;\n  var distance = Math.hypot(dx, dy);\n  var angle = -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var origin = [cx, cy];\n  return {\n    angle: angle,\n    distance: distance,\n    origin: origin\n  };\n}\n\nfunction touchIds(event) {\n  return getCurrentTargetTouchList(event).map(function (touch) {\n    return touch.identifier;\n  });\n}\n\nfunction touchDistanceAngle(event, ids) {\n  var _Array$from$filter = Array.from(event.touches).filter(function (touch) {\n    return ids.includes(touch.identifier);\n  }),\n      _Array$from$filter2 = _slicedToArray(_Array$from$filter, 2),\n      P1 = _Array$from$filter2[0],\n      P2 = _Array$from$filter2[1];\n\n  return distanceAngle(P1, P2);\n}\n\nfunction pointerId(event) {\n  var valueEvent = getValueEvent(event);\n  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;\n}\n\nfunction pointerValues(event) {\n  var valueEvent = getValueEvent(event);\n  return [valueEvent.clientX, valueEvent.clientY];\n}\n\nvar LINE_HEIGHT = 40;\nvar PAGE_HEIGHT = 800;\n\nfunction wheelValues(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY,\n      deltaMode = event.deltaMode;\n\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT;\n    deltaY *= LINE_HEIGHT;\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT;\n    deltaY *= PAGE_HEIGHT;\n  }\n\n  return [deltaX, deltaY];\n}\n\nfunction scrollValues(event) {\n  var _ref, _ref2;\n\n  var _event$currentTarget2 = event.currentTarget,\n      scrollX = _event$currentTarget2.scrollX,\n      scrollY = _event$currentTarget2.scrollY,\n      scrollLeft = _event$currentTarget2.scrollLeft,\n      scrollTop = _event$currentTarget2.scrollTop;\n  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];\n}\n\nfunction getEventDetails(event) {\n  var payload = {};\n  if ('buttons' in event) payload.buttons = event.buttons;\n\n  if ('shiftKey' in event) {\n    var shiftKey = event.shiftKey,\n        altKey = event.altKey,\n        metaKey = event.metaKey,\n        ctrlKey = event.ctrlKey;\n    Object.assign(payload, {\n      shiftKey: shiftKey,\n      altKey: altKey,\n      metaKey: metaKey,\n      ctrlKey: ctrlKey\n    });\n  }\n\n  return payload;\n}\n\nfunction call(v) {\n  if (typeof v === 'function') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\n\nfunction noop() {}\n\nfunction chain() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n\n    var _iterator = _createForOfIteratorHelper(fns),\n        _step2;\n\n    try {\n      for (_iterator.s(); !(_step2 = _iterator.n()).done;) {\n        var fn = _step2.value;\n        result = fn.apply(this, arguments) || result;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result;\n  };\n}\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n\nvar BEFORE_LAST_KINEMATICS_DELAY = 32;\n\nvar Engine = /*#__PURE__*/function () {\n  function Engine(ctrl, args, key) {\n    _classCallCheck(this, Engine);\n\n    this.ctrl = ctrl;\n    this.args = args;\n    this.key = key;\n\n    if (!this.state) {\n      this.state = {};\n      this.computeValues([0, 0]);\n      this.computeInitial();\n      if (this.init) this.init();\n      this.reset();\n    }\n  }\n\n  _createClass(Engine, [{\n    key: \"state\",\n    get: function get() {\n      return this.ctrl.state[this.key];\n    },\n    set: function set(state) {\n      this.ctrl.state[this.key] = state;\n    }\n  }, {\n    key: \"shared\",\n    get: function get() {\n      return this.ctrl.state.shared;\n    }\n  }, {\n    key: \"eventStore\",\n    get: function get() {\n      return this.ctrl.gestureEventStores[this.key];\n    }\n  }, {\n    key: \"timeoutStore\",\n    get: function get() {\n      return this.ctrl.gestureTimeoutStores[this.key];\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return this.ctrl.config[this.key];\n    }\n  }, {\n    key: \"sharedConfig\",\n    get: function get() {\n      return this.ctrl.config.shared;\n    }\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.ctrl.handlers[this.key];\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var state = this.state,\n          shared = this.shared,\n          ingKey = this.ingKey,\n          args = this.args;\n      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;\n      state._step = [false, false];\n      state.intentional = false;\n      state._movement = [0, 0];\n      state._distance = [0, 0];\n      state._direction = [0, 0];\n      state._delta = [0, 0];\n      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];\n      state.args = args;\n      state.axis = undefined;\n      state.memo = undefined;\n      state.elapsedTime = 0;\n      state.direction = [0, 0];\n      state.distance = [0, 0];\n      state.overflow = [0, 0];\n      state._movementBound = [false, false];\n      state.velocity = [0, 0];\n      state.movement = [0, 0];\n      state.delta = [0, 0];\n      state.timeStamp = 0;\n    }\n  }, {\n    key: \"start\",\n    value: function start(event) {\n      var state = this.state;\n      var config = this.config;\n\n      if (!state._active) {\n        this.reset();\n        this.computeInitial();\n        state._active = true;\n        state.target = event.target;\n        state.currentTarget = event.currentTarget;\n        state.lastOffset = config.from ? call(config.from, state) : state.offset;\n        state.offset = state.lastOffset;\n      }\n\n      state.startTime = state.timeStamp = event.timeStamp;\n    }\n  }, {\n    key: \"computeValues\",\n    value: function computeValues(values) {\n      var state = this.state;\n      state._values = values;\n      state.values = this.config.transform(values);\n    }\n  }, {\n    key: \"computeInitial\",\n    value: function computeInitial() {\n      var state = this.state;\n      state._initial = state._values;\n      state.initial = state.values;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute(event) {\n      var state = this.state,\n          config = this.config,\n          shared = this.shared;\n      state.args = this.args;\n      var dt = 0;\n\n      if (event) {\n        state.event = event;\n        if (config.preventDefault && event.cancelable) state.event.preventDefault();\n        state.type = event.type;\n        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;\n        shared.locked = !!document.pointerLockElement;\n        Object.assign(shared, getEventDetails(event));\n        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;\n        dt = event.timeStamp - state.timeStamp;\n        state.timeStamp = event.timeStamp;\n        state.elapsedTime = state.timeStamp - state.startTime;\n      }\n\n      if (state._active) {\n        var _absoluteDelta = state._delta.map(Math.abs);\n\n        _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._distance, _absoluteDelta);\n      }\n\n      if (this.axisIntent) this.axisIntent(event);\n\n      var _state$_movement = _slicedToArray(state._movement, 2),\n          _m0 = _state$_movement[0],\n          _m1 = _state$_movement[1];\n\n      var _config$threshold = _slicedToArray(config.threshold, 2),\n          t0 = _config$threshold[0],\n          t1 = _config$threshold[1];\n\n      var _step = state._step,\n          values = state.values;\n\n      if (config.hasCustomTransform) {\n        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];\n        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];\n      } else {\n        if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;\n        if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;\n      }\n\n      state.intentional = _step[0] !== false || _step[1] !== false;\n      if (!state.intentional) return;\n      var movement = [0, 0];\n\n      if (config.hasCustomTransform) {\n        var _values2 = _slicedToArray(values, 2),\n            v0 = _values2[0],\n            v1 = _values2[1];\n\n        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;\n        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;\n      } else {\n        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;\n        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;\n      }\n\n      if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);\n      var previousOffset = state.offset;\n      var gestureIsActive = state._active && !state._blocked || state.active;\n\n      if (gestureIsActive) {\n        state.first = state._active && !state.active;\n        state.last = !state._active && state.active;\n        state.active = shared[this.ingKey] = state._active;\n\n        if (event) {\n          if (state.first) {\n            if ('bounds' in config) state._bounds = call(config.bounds, state);\n            if (this.setup) this.setup();\n          }\n\n          state.movement = movement;\n          this.computeOffset();\n        }\n      }\n\n      var _state$offset = _slicedToArray(state.offset, 2),\n          ox = _state$offset[0],\n          oy = _state$offset[1];\n\n      var _state$_bounds = _slicedToArray(state._bounds, 2),\n          _state$_bounds$ = _slicedToArray(_state$_bounds[0], 2),\n          x0 = _state$_bounds$[0],\n          x1 = _state$_bounds$[1],\n          _state$_bounds$2 = _slicedToArray(_state$_bounds[1], 2),\n          y0 = _state$_bounds$2[0],\n          y1 = _state$_bounds$2[1];\n\n      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];\n      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;\n      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;\n      var rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];\n      state.offset = (0,_maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(state._bounds, state.offset, rubberband);\n      state.delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n      this.computeMovement();\n\n      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {\n        state.delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);\n        var absoluteDelta = state.delta.map(Math.abs);\n        _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state.distance, absoluteDelta);\n        state.direction = state.delta.map(Math.sign);\n        state._direction = state._delta.map(Math.sign);\n\n        if (!state.first && dt > 0) {\n          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];\n        }\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit() {\n      var state = this.state;\n      var shared = this.shared;\n      var config = this.config;\n      if (!state._active) this.clean();\n      if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;\n      var memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, _defineProperty2({}, this.aliasKey, state.values)));\n      if (memo !== undefined) state.memo = memo;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.eventStore.clean();\n      this.timeoutStore.clean();\n    }\n  }]);\n\n  return Engine;\n}();\n\nfunction selectAxis(_ref3, threshold) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      dx = _ref4[0],\n      dy = _ref4[1];\n\n  var absDx = Math.abs(dx);\n  var absDy = Math.abs(dy);\n\n  if (absDx > absDy && absDx > threshold) {\n    return 'x';\n  }\n\n  if (absDy > absDx && absDy > threshold) {\n    return 'y';\n  }\n\n  return undefined;\n}\n\nvar CoordinatesEngine = /*#__PURE__*/function (_Engine) {\n  _inherits(CoordinatesEngine, _Engine);\n\n  var _super = _createSuper(CoordinatesEngine);\n\n  function CoordinatesEngine() {\n    var _this;\n\n    _classCallCheck(this, CoordinatesEngine);\n\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"aliasKey\", 'xy');\n\n    return _this;\n  }\n\n  _createClass(CoordinatesEngine, [{\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(CoordinatesEngine.prototype), \"reset\", this).call(this);\n\n      this.state.axis = undefined;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.state.offset = [0, 0];\n      this.state.lastOffset = [0, 0];\n    }\n  }, {\n    key: \"computeOffset\",\n    value: function computeOffset() {\n      this.state.offset = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(this.state.lastOffset, this.state.movement);\n    }\n  }, {\n    key: \"computeMovement\",\n    value: function computeMovement() {\n      this.state.movement = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(this.state.offset, this.state.lastOffset);\n    }\n  }, {\n    key: \"axisIntent\",\n    value: function axisIntent(event) {\n      var state = this.state;\n      var config = this.config;\n\n      if (!state.axis && event) {\n        var threshold = _typeof(config.axisThreshold) === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;\n        state.axis = selectAxis(state._movement, threshold);\n      }\n\n      state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;\n    }\n  }, {\n    key: \"restrictToAxis\",\n    value: function restrictToAxis(v) {\n      if (this.config.axis || this.config.lockDirection) {\n        switch (this.state.axis) {\n          case 'x':\n            v[1] = 0;\n            break;\n\n          case 'y':\n            v[0] = 0;\n            break;\n        }\n      }\n    }\n  }]);\n\n  return CoordinatesEngine;\n}(Engine);\n\nvar identity = function identity(v) {\n  return v;\n};\n\nvar DEFAULT_RUBBERBAND = 0.15;\nvar commonConfigResolver = {\n  enabled: function enabled() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  },\n  eventOptions: function eventOptions(value, _k, config) {\n    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);\n  },\n  preventDefault: function preventDefault() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return value;\n  },\n  rubberband: function rubberband() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    switch (value) {\n      case true:\n        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];\n\n      case false:\n        return [0, 0];\n\n      default:\n        return _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n    }\n  },\n  from: function from(value) {\n    if (typeof value === 'function') return value;\n    if (value != null) return _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);\n  },\n  transform: function transform(value, _k, config) {\n    var transform = value || config.shared.transform;\n    this.hasCustomTransform = !!transform;\n\n    if (true) {\n      var originalTransform = transform || identity;\n      return function (v) {\n        var r = originalTransform(v);\n\n        if (!isFinite(r[0]) || !isFinite(r[1])) {\n          console.warn(\"[@use-gesture]: config.transform() must produce a valid result, but it was: [\".concat(r[0], \",\").concat([1], \"]\"));\n        }\n\n        return r;\n      };\n    }\n\n    return transform || identity;\n  },\n  threshold: function threshold(value) {\n    return _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, 0);\n  }\n};\n\nif (true) {\n  Object.assign(commonConfigResolver, {\n    domTarget: function domTarget(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `domTarget` option has been renamed to `target`.\");\n      }\n\n      return NaN;\n    },\n    lockDirection: function lockDirection(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`\");\n      }\n\n      return NaN;\n    },\n    initial: function initial(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `initial` option has been renamed to `from`.\");\n      }\n\n      return NaN;\n    }\n  });\n}\n\nvar DEFAULT_AXIS_THRESHOLD = 0;\n\nvar coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  axis: function axis(_v, _k, _ref5) {\n    var axis = _ref5.axis;\n    this.lockDirection = axis === 'lock';\n    if (!this.lockDirection) return axis;\n  },\n  axisThreshold: function axisThreshold() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_AXIS_THRESHOLD;\n    return value;\n  },\n  bounds: function bounds() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof value === 'function') {\n      return function (state) {\n        return coordinatesConfigResolver.bounds(value(state));\n      };\n    }\n\n    if ('current' in value) {\n      return function () {\n        return value.current;\n      };\n    }\n\n    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {\n      return value;\n    }\n\n    var _value$left = value.left,\n        left = _value$left === void 0 ? -Infinity : _value$left,\n        _value$right = value.right,\n        right = _value$right === void 0 ? Infinity : _value$right,\n        _value$top = value.top,\n        top = _value$top === void 0 ? -Infinity : _value$top,\n        _value$bottom = value.bottom,\n        bottom = _value$bottom === void 0 ? Infinity : _value$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nvar DISPLACEMENT = 10;\nvar KEYS_DELTA_MAP = {\n  ArrowRight: function ArrowRight() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [DISPLACEMENT * factor, 0];\n  },\n  ArrowLeft: function ArrowLeft() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [-DISPLACEMENT * factor, 0];\n  },\n  ArrowUp: function ArrowUp() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [0, -DISPLACEMENT * factor];\n  },\n  ArrowDown: function ArrowDown() {\n    var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return [0, DISPLACEMENT * factor];\n  }\n};\n\nvar DragEngine = /*#__PURE__*/function (_CoordinatesEngine) {\n  _inherits(DragEngine, _CoordinatesEngine);\n\n  var _super2 = _createSuper(DragEngine);\n\n  function DragEngine() {\n    var _this2;\n\n    _classCallCheck(this, DragEngine);\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    _this2 = _super2.call.apply(_super2, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this2), \"ingKey\", 'dragging');\n\n    return _this2;\n  }\n\n  _createClass(DragEngine, [{\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(DragEngine.prototype), \"reset\", this).call(this);\n\n      var state = this.state;\n      state._pointerId = undefined;\n      state._pointerActive = false;\n      state._keyboardActive = false;\n      state._preventScroll = false;\n      state._delayed = false;\n      state.swipe = [0, 0];\n      state.tap = false;\n      state.canceled = false;\n      state.cancel = this.cancel.bind(this);\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var state = this.state;\n\n      if (state._bounds instanceof HTMLElement) {\n        var boundRect = state._bounds.getBoundingClientRect();\n\n        var targetRect = state.currentTarget.getBoundingClientRect();\n        var _bounds = {\n          left: boundRect.left - targetRect.left + state.offset[0],\n          right: boundRect.right - targetRect.right + state.offset[0],\n          top: boundRect.top - targetRect.top + state.offset[1],\n          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]\n        };\n        state._bounds = coordinatesConfigResolver.bounds(_bounds);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this3 = this;\n\n      var state = this.state;\n      if (state.canceled) return;\n      state.canceled = true;\n      state._active = false;\n      setTimeout(function () {\n        _this3.compute();\n\n        _this3.emit();\n      }, 0);\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive() {\n      this.state._active = this.state._pointerActive || this.state._keyboardActive;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.pointerClean();\n      this.state._pointerActive = false;\n      this.state._keyboardActive = false;\n\n      _get(_getPrototypeOf(DragEngine.prototype), \"clean\", this).call(this);\n    }\n  }, {\n    key: \"pointerDown\",\n    value: function pointerDown(event) {\n      var config = this.config;\n      var state = this.state;\n      if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;\n      var ctrlIds = this.ctrl.setEventIds(event);\n\n      if (config.pointerCapture) {\n        event.target.setPointerCapture(event.pointerId);\n      }\n\n      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;\n      this.start(event);\n      this.setupPointer(event);\n      state._pointerId = pointerId(event);\n      state._pointerActive = true;\n      this.computeValues(pointerValues(event));\n      this.computeInitial();\n\n      if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {\n        state._active = false;\n        this.setupScrollPrevention(event);\n      } else if (config.delay > 0) {\n        this.setupDelayTrigger(event);\n\n        if (config.triggerAllEvents) {\n          this.compute(event);\n          this.emit();\n        }\n      } else {\n        this.startPointerDrag(event);\n      }\n    }\n  }, {\n    key: \"startPointerDrag\",\n    value: function startPointerDrag(event) {\n      var state = this.state;\n      state._active = true;\n      state._preventScroll = true;\n      state._delayed = false;\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"pointerMove\",\n    value: function pointerMove(event) {\n      var state = this.state;\n      var config = this.config;\n      if (!state._pointerActive) return;\n      if (state.type === event.type && event.timeStamp === state.timeStamp) return;\n      var id = pointerId(event);\n      if (state._pointerId !== undefined && id !== state._pointerId) return;\n\n      var _values = pointerValues(event);\n\n      if (document.pointerLockElement === event.target) {\n        state._delta = [event.movementX, event.movementY];\n      } else {\n        state._delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(_values, state._values);\n        this.computeValues(_values);\n      }\n\n      _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.compute(event);\n\n      if (state._delayed && state.intentional) {\n        this.timeoutStore.remove('dragDelay');\n        state.active = false;\n        this.startPointerDrag(event);\n        return;\n      }\n\n      if (config.preventScrollAxis && !state._preventScroll) {\n        if (state.axis) {\n          if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {\n            state._active = false;\n            this.clean();\n            return;\n          } else {\n            this.timeoutStore.remove('startPointerDrag');\n            this.startPointerDrag(event);\n            return;\n          }\n        } else {\n          return;\n        }\n      }\n\n      this.emit();\n    }\n  }, {\n    key: \"pointerUp\",\n    value: function pointerUp(event) {\n      this.ctrl.setEventIds(event);\n\n      try {\n        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {\n          ;\n          event.target.releasePointerCapture(event.pointerId);\n        }\n      } catch (_unused) {\n        if (true) {\n          console.warn(\"[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \\n\\nPlease upgrade to the latest version.\");\n        }\n      }\n\n      var state = this.state;\n      var config = this.config;\n      if (!state._active || !state._pointerActive) return;\n      var id = pointerId(event);\n      if (state._pointerId !== undefined && id !== state._pointerId) return;\n      this.state._pointerActive = false;\n      this.setActive();\n      this.compute(event);\n\n      var _state$_distance = _slicedToArray(state._distance, 2),\n          dx = _state$_distance[0],\n          dy = _state$_distance[1];\n\n      state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;\n\n      if (state.tap && config.filterTaps) {\n        state._force = true;\n      } else {\n        var _state$direction = _slicedToArray(state.direction, 2),\n            dirx = _state$direction[0],\n            diry = _state$direction[1];\n\n        var _state$velocity = _slicedToArray(state.velocity, 2),\n            vx = _state$velocity[0],\n            vy = _state$velocity[1];\n\n        var _state$movement = _slicedToArray(state.movement, 2),\n            mx = _state$movement[0],\n            my = _state$movement[1];\n\n        var _config$swipe$velocit = _slicedToArray(config.swipe.velocity, 2),\n            svx = _config$swipe$velocit[0],\n            svy = _config$swipe$velocit[1];\n\n        var _config$swipe$distanc = _slicedToArray(config.swipe.distance, 2),\n            sx = _config$swipe$distanc[0],\n            sy = _config$swipe$distanc[1];\n\n        var sdt = config.swipe.duration;\n\n        if (state.elapsedTime < sdt) {\n          if (Math.abs(vx) > svx && Math.abs(mx) > sx) state.swipe[0] = dirx;\n          if (Math.abs(vy) > svy && Math.abs(my) > sy) state.swipe[1] = diry;\n        }\n      }\n\n      this.emit();\n    }\n  }, {\n    key: \"pointerClick\",\n    value: function pointerClick(event) {\n      if (!this.state.tap) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  }, {\n    key: \"setupPointer\",\n    value: function setupPointer(event) {\n      var config = this.config;\n      var device = config.device;\n\n      if (true) {\n        try {\n          if (device === 'pointer' && config.preventScrollDelay === undefined) {\n            var currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;\n            var style = window.getComputedStyle(currentTarget);\n\n            if (style.touchAction === 'auto') {\n              console.warn(\"[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\\n\\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.\", currentTarget);\n            }\n          }\n        } catch (_unused2) {}\n      }\n\n      if (config.pointerLock) {\n        event.currentTarget.requestPointerLock();\n      }\n\n      if (!config.pointerCapture) {\n        this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));\n        this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));\n        this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));\n      }\n    }\n  }, {\n    key: \"pointerClean\",\n    value: function pointerClean() {\n      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {\n        document.exitPointerLock();\n      }\n    }\n  }, {\n    key: \"preventScroll\",\n    value: function preventScroll(event) {\n      if (this.state._preventScroll && event.cancelable) {\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"setupScrollPrevention\",\n    value: function setupScrollPrevention(event) {\n      this.state._preventScroll = false;\n      persistEvent(event);\n      var remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {\n        passive: false\n      });\n      this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);\n      this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);\n      this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);\n    }\n  }, {\n    key: \"setupDelayTrigger\",\n    value: function setupDelayTrigger(event) {\n      var _this4 = this;\n\n      this.state._delayed = true;\n      this.timeoutStore.add('dragDelay', function () {\n        _this4.state._step = [0, 0];\n\n        _this4.startPointerDrag(event);\n      }, this.config.delay);\n    }\n  }, {\n    key: \"keyDown\",\n    value: function keyDown(event) {\n      var deltaFn = KEYS_DELTA_MAP[event.key];\n\n      if (deltaFn) {\n        var state = this.state;\n        var factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;\n        this.start(event);\n        state._delta = deltaFn(factor);\n        state._keyboardActive = true;\n        _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n        this.compute(event);\n        this.emit();\n      }\n    }\n  }, {\n    key: \"keyUp\",\n    value: function keyUp(event) {\n      if (!(event.key in KEYS_DELTA_MAP)) return;\n      this.state._keyboardActive = false;\n      this.setActive();\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      var device = this.config.device;\n      bindFunction(device, 'start', this.pointerDown.bind(this));\n\n      if (this.config.pointerCapture) {\n        bindFunction(device, 'change', this.pointerMove.bind(this));\n        bindFunction(device, 'end', this.pointerUp.bind(this));\n        bindFunction(device, 'cancel', this.pointerUp.bind(this));\n        bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));\n      }\n\n      if (this.config.keys) {\n        bindFunction('key', 'down', this.keyDown.bind(this));\n        bindFunction('key', 'up', this.keyUp.bind(this));\n      }\n\n      if (this.config.filterTaps) {\n        bindFunction('click', '', this.pointerClick.bind(this), {\n          capture: true,\n          passive: false\n        });\n      }\n    }\n  }]);\n\n  return DragEngine;\n}(CoordinatesEngine);\n\nfunction persistEvent(event) {\n  'persist' in event && typeof event.persist === 'function' && event.persist();\n}\n\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\n\nfunction supportsTouchEvents() {\n  return isBrowser && 'ontouchstart' in window;\n}\n\nfunction isTouchScreen() {\n  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;\n}\n\nfunction supportsPointerEvents() {\n  return isBrowser && 'onpointerdown' in window;\n}\n\nfunction supportsPointerLock() {\n  return isBrowser && 'exitPointerLock' in window.document;\n}\n\nfunction supportsGestureEvents() {\n  try {\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar SUPPORT = {\n  isBrowser: isBrowser,\n  gesture: supportsGestureEvents(),\n  touch: isTouchScreen(),\n  touchscreen: isTouchScreen(),\n  pointer: supportsPointerEvents(),\n  pointerLock: supportsPointerLock()\n};\nvar DEFAULT_PREVENT_SCROLL_DELAY = 250;\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 50;\nvar DEFAULT_SWIPE_DURATION = 250;\nvar DEFAULT_DRAG_AXIS_THRESHOLD = {\n  mouse: 0,\n  touch: 0,\n  pen: 8\n};\n\nvar dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  device: function device(_v, _k, _ref6) {\n    var _ref6$pointer = _ref6.pointer;\n    _ref6$pointer = _ref6$pointer === void 0 ? {} : _ref6$pointer;\n    var _ref6$pointer$touch = _ref6$pointer.touch,\n        touch = _ref6$pointer$touch === void 0 ? false : _ref6$pointer$touch,\n        _ref6$pointer$lock = _ref6$pointer.lock,\n        lock = _ref6$pointer$lock === void 0 ? false : _ref6$pointer$lock,\n        _ref6$pointer$mouse = _ref6$pointer.mouse,\n        mouse = _ref6$pointer$mouse === void 0 ? false : _ref6$pointer$mouse;\n    this.pointerLock = lock && SUPPORT.pointerLock;\n    if (SUPPORT.touch && touch) return 'touch';\n    if (this.pointerLock) return 'mouse';\n    if (SUPPORT.pointer && !mouse) return 'pointer';\n    if (SUPPORT.touch) return 'touch';\n    return 'mouse';\n  },\n  preventScrollAxis: function preventScrollAxis(value, _k, _ref7) {\n    var preventScroll = _ref7.preventScroll;\n    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;\n    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;\n    return value ? value : preventScroll !== undefined ? 'y' : undefined;\n  },\n  pointerCapture: function pointerCapture(_v, _k, _ref8) {\n    var _ref8$pointer = _ref8.pointer;\n    _ref8$pointer = _ref8$pointer === void 0 ? {} : _ref8$pointer;\n    var _ref8$pointer$capture = _ref8$pointer.capture,\n        capture = _ref8$pointer$capture === void 0 ? true : _ref8$pointer$capture,\n        _ref8$pointer$buttons = _ref8$pointer.buttons,\n        buttons = _ref8$pointer$buttons === void 0 ? 1 : _ref8$pointer$buttons;\n    this.pointerButtons = buttons;\n    return !this.pointerLock && this.device === 'pointer' && capture;\n  },\n  keys: function keys() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  },\n  threshold: function threshold(value, _k, _ref9) {\n    var _ref9$filterTaps = _ref9.filterTaps,\n        filterTaps = _ref9$filterTaps === void 0 ? false : _ref9$filterTaps,\n        _ref9$tapsThreshold = _ref9.tapsThreshold,\n        tapsThreshold = _ref9$tapsThreshold === void 0 ? 3 : _ref9$tapsThreshold,\n        _ref9$axis = _ref9.axis,\n        axis = _ref9$axis === void 0 ? undefined : _ref9$axis;\n    var threshold = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);\n    this.filterTaps = filterTaps;\n    this.tapsThreshold = tapsThreshold;\n    return threshold;\n  },\n  swipe: function swipe() {\n    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref10$velocity = _ref10.velocity,\n        velocity = _ref10$velocity === void 0 ? DEFAULT_SWIPE_VELOCITY : _ref10$velocity,\n        _ref10$distance = _ref10.distance,\n        distance = _ref10$distance === void 0 ? DEFAULT_SWIPE_DISTANCE : _ref10$distance,\n        _ref10$duration = _ref10.duration,\n        duration = _ref10$duration === void 0 ? DEFAULT_SWIPE_DURATION : _ref10$duration;\n\n    return {\n      velocity: this.transform(_maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(velocity)),\n      distance: this.transform(_maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(distance)),\n      duration: duration\n    };\n  },\n  delay: function delay() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  },\n  axisThreshold: function axisThreshold(value) {\n    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;\n    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);\n  }\n});\n\nif (true) {\n  Object.assign(dragConfigResolver, {\n    useTouch: function useTouch(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.\");\n      }\n\n      return NaN;\n    },\n    experimental_preventWindowScrollY: function experimental_preventWindowScrollY(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.\");\n      }\n\n      return NaN;\n    },\n    swipeVelocity: function swipeVelocity(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.\");\n      }\n\n      return NaN;\n    },\n    swipeDistance: function swipeDistance(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.\");\n      }\n\n      return NaN;\n    },\n    swipeDuration: function swipeDuration(value) {\n      if (value !== undefined) {\n        throw Error(\"[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.\");\n      }\n\n      return NaN;\n    }\n  });\n}\n\nvar SCALE_ANGLE_RATIO_INTENT_DEG = 30;\nvar PINCH_WHEEL_RATIO = 100;\n\nvar PinchEngine = /*#__PURE__*/function (_Engine2) {\n  _inherits(PinchEngine, _Engine2);\n\n  var _super3 = _createSuper(PinchEngine);\n\n  function PinchEngine() {\n    var _this5;\n\n    _classCallCheck(this, PinchEngine);\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    _this5 = _super3.call.apply(_super3, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this5), \"ingKey\", 'pinching');\n\n    _defineProperty(_assertThisInitialized(_this5), \"aliasKey\", 'da');\n\n    return _this5;\n  }\n\n  _createClass(PinchEngine, [{\n    key: \"init\",\n    value: function init() {\n      this.state.offset = [1, 0];\n      this.state.lastOffset = [1, 0];\n      this.state._pointerEvents = new Map();\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      _get(_getPrototypeOf(PinchEngine.prototype), \"reset\", this).call(this);\n\n      var state = this.state;\n      state._touchIds = [];\n      state.canceled = false;\n      state.cancel = this.cancel.bind(this);\n      state.turns = 0;\n    }\n  }, {\n    key: \"computeOffset\",\n    value: function computeOffset() {\n      var _this$state = this.state,\n          type = _this$state.type,\n          movement = _this$state.movement,\n          lastOffset = _this$state.lastOffset;\n\n      if (type === 'wheel') {\n        this.state.offset = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(movement, lastOffset);\n      } else {\n        this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];\n      }\n    }\n  }, {\n    key: \"computeMovement\",\n    value: function computeMovement() {\n      var _this$state2 = this.state,\n          offset = _this$state2.offset,\n          lastOffset = _this$state2.lastOffset;\n      this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];\n    }\n  }, {\n    key: \"axisIntent\",\n    value: function axisIntent() {\n      var state = this.state;\n\n      var _state$_movement2 = _slicedToArray(state._movement, 2),\n          _m0 = _state$_movement2[0],\n          _m1 = _state$_movement2[1];\n\n      if (!state.axis) {\n        var axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);\n        if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';\n      }\n    }\n  }, {\n    key: \"restrictToAxis\",\n    value: function restrictToAxis(v) {\n      if (this.config.lockDirection) {\n        if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this6 = this;\n\n      var state = this.state;\n      if (state.canceled) return;\n      setTimeout(function () {\n        state.canceled = true;\n        state._active = false;\n\n        _this6.compute();\n\n        _this6.emit();\n      }, 0);\n    }\n  }, {\n    key: \"touchStart\",\n    value: function touchStart(event) {\n      this.ctrl.setEventIds(event);\n      var state = this.state;\n      var ctrlTouchIds = this.ctrl.touchIds;\n\n      if (state._active) {\n        if (state._touchIds.every(function (id) {\n          return ctrlTouchIds.has(id);\n        })) return;\n      }\n\n      if (ctrlTouchIds.size < 2) return;\n      this.start(event);\n      state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);\n      var payload = touchDistanceAngle(event, state._touchIds);\n      this.pinchStart(event, payload);\n    }\n  }, {\n    key: \"pointerStart\",\n    value: function pointerStart(event) {\n      if (event.buttons != null && event.buttons % 2 !== 1) return;\n      this.ctrl.setEventIds(event);\n      event.target.setPointerCapture(event.pointerId);\n      var state = this.state;\n      var _pointerEvents = state._pointerEvents;\n      var ctrlPointerIds = this.ctrl.pointerIds;\n\n      if (state._active) {\n        if (Array.from(_pointerEvents.keys()).every(function (id) {\n          return ctrlPointerIds.has(id);\n        })) return;\n      }\n\n      if (_pointerEvents.size < 2) {\n        _pointerEvents.set(event.pointerId, event);\n      }\n\n      if (state._pointerEvents.size < 2) return;\n      this.start(event);\n      var payload = distanceAngle.apply(void 0, _toConsumableArray(Array.from(_pointerEvents.values())));\n      this.pinchStart(event, payload);\n    }\n  }, {\n    key: \"pinchStart\",\n    value: function pinchStart(event, payload) {\n      var state = this.state;\n      state.origin = payload.origin;\n      this.computeValues([payload.distance, payload.angle]);\n      this.computeInitial();\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"touchMove\",\n    value: function touchMove(event) {\n      if (!this.state._active) return;\n      var payload = touchDistanceAngle(event, this.state._touchIds);\n      this.pinchMove(event, payload);\n    }\n  }, {\n    key: \"pointerMove\",\n    value: function pointerMove(event) {\n      var _pointerEvents = this.state._pointerEvents;\n\n      if (_pointerEvents.has(event.pointerId)) {\n        _pointerEvents.set(event.pointerId, event);\n      }\n\n      if (!this.state._active) return;\n      var payload = distanceAngle.apply(void 0, _toConsumableArray(Array.from(_pointerEvents.values())));\n      this.pinchMove(event, payload);\n    }\n  }, {\n    key: \"pinchMove\",\n    value: function pinchMove(event, payload) {\n      var state = this.state;\n      var prev_a = state._values[1];\n      var delta_a = payload.angle - prev_a;\n      var delta_turns = 0;\n      if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);\n      this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);\n      state.origin = payload.origin;\n      state.turns = delta_turns;\n      state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"touchEnd\",\n    value: function touchEnd(event) {\n      var _this7 = this;\n\n      this.ctrl.setEventIds(event);\n      if (!this.state._active) return;\n\n      if (this.state._touchIds.some(function (id) {\n        return !_this7.ctrl.touchIds.has(id);\n      })) {\n        this.state._active = false;\n        this.compute(event);\n        this.emit();\n      }\n    }\n  }, {\n    key: \"pointerEnd\",\n    value: function pointerEnd(event) {\n      var state = this.state;\n      this.ctrl.setEventIds(event);\n\n      try {\n        event.target.releasePointerCapture(event.pointerId);\n      } catch (_unused) {}\n\n      if (state._pointerEvents.has(event.pointerId)) {\n        state._pointerEvents[\"delete\"](event.pointerId);\n      }\n\n      if (!state._active) return;\n\n      if (state._pointerEvents.size < 2) {\n        state._active = false;\n        this.compute(event);\n        this.emit();\n      }\n    }\n  }, {\n    key: \"gestureStart\",\n    value: function gestureStart(event) {\n      if (event.cancelable) event.preventDefault();\n      var state = this.state;\n      if (state._active) return;\n      this.start(event);\n      this.computeValues([event.scale, event.rotation]);\n      state.origin = [event.clientX, event.clientY];\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"gestureMove\",\n    value: function gestureMove(event) {\n      if (event.cancelable) event.preventDefault();\n      if (!this.state._active) return;\n      var state = this.state;\n      this.computeValues([event.scale, event.rotation]);\n      state.origin = [event.clientX, event.clientY];\n      var _previousMovement = state._movement;\n      state._movement = [event.scale - 1, event.rotation];\n      state._delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state._movement, _previousMovement);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"gestureEnd\",\n    value: function gestureEnd(event) {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"wheel\",\n    value: function wheel(event) {\n      var modifierKey = this.config.modifierKey;\n      if (modifierKey && !event[modifierKey]) return;\n      if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);\n      this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n    }\n  }, {\n    key: \"wheelStart\",\n    value: function wheelStart(event) {\n      this.start(event);\n      this.wheelChange(event);\n    }\n  }, {\n    key: \"wheelChange\",\n    value: function wheelChange(event) {\n      var isR3f = ('uv' in event);\n\n      if (!isR3f) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n\n        if ( true && !event.defaultPrevented) {\n          console.warn(\"[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\\n\\nThis message will only appear in development mode.\");\n        }\n      }\n\n      var state = this.state;\n      state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];\n      _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.state.origin = [event.clientX, event.clientY];\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"wheelEnd\",\n    value: function wheelEnd() {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute();\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      var device = this.config.device;\n\n      if (!!device) {\n        bindFunction(device, 'start', this[device + 'Start'].bind(this));\n        bindFunction(device, 'change', this[device + 'Move'].bind(this));\n        bindFunction(device, 'end', this[device + 'End'].bind(this));\n        bindFunction(device, 'cancel', this[device + 'End'].bind(this));\n      }\n\n      bindFunction('wheel', '', this.wheel.bind(this), {\n        passive: false\n      });\n    }\n  }]);\n\n  return PinchEngine;\n}(Engine);\n\nvar pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {\n  device: function device(_v, _k, _ref11) {\n    var shared = _ref11.shared,\n        _ref11$pointer = _ref11.pointer;\n    _ref11$pointer = _ref11$pointer === void 0 ? {} : _ref11$pointer;\n    var _ref11$pointer$touch = _ref11$pointer.touch,\n        touch = _ref11$pointer$touch === void 0 ? false : _ref11$pointer$touch;\n    var sharedConfig = shared;\n    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';\n    if (SUPPORT.touch && touch) return 'touch';\n\n    if (SUPPORT.touchscreen) {\n      if (SUPPORT.pointer) return 'pointer';\n      if (SUPPORT.touch) return 'touch';\n    }\n  },\n  bounds: function bounds(_v, _k, _ref12) {\n    var _ref12$scaleBounds = _ref12.scaleBounds,\n        scaleBounds = _ref12$scaleBounds === void 0 ? {} : _ref12$scaleBounds,\n        _ref12$angleBounds = _ref12.angleBounds,\n        angleBounds = _ref12$angleBounds === void 0 ? {} : _ref12$angleBounds;\n\n    var _scaleBounds = function _scaleBounds(state) {\n      var D = assignDefault(call(scaleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(call(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];\n    return function (state) {\n      return [_scaleBounds(state), _angleBounds(state)];\n    };\n  },\n  threshold: function threshold(value, _k, config) {\n    this.lockDirection = config.axis === 'lock';\n    var threshold = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, this.lockDirection ? [0.1, 3] : 0);\n    return threshold;\n  },\n  modifierKey: function modifierKey(value) {\n    if (value === undefined) return 'ctrlKey';\n    return value;\n  }\n});\n\nvar MoveEngine = /*#__PURE__*/function (_CoordinatesEngine2) {\n  _inherits(MoveEngine, _CoordinatesEngine2);\n\n  var _super4 = _createSuper(MoveEngine);\n\n  function MoveEngine() {\n    var _this8;\n\n    _classCallCheck(this, MoveEngine);\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    _this8 = _super4.call.apply(_super4, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this8), \"ingKey\", 'moving');\n\n    return _this8;\n  }\n\n  _createClass(MoveEngine, [{\n    key: \"move\",\n    value: function move(event) {\n      if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n      if (!this.state._active) this.moveStart(event);else this.moveChange(event);\n      this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));\n    }\n  }, {\n    key: \"moveStart\",\n    value: function moveStart(event) {\n      this.start(event);\n      this.computeValues(pointerValues(event));\n      this.compute(event);\n      this.computeInitial();\n      this.emit();\n    }\n  }, {\n    key: \"moveChange\",\n    value: function moveChange(event) {\n      if (!this.state._active) return;\n      var values = pointerValues(event);\n      var state = this.state;\n      state._delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n      _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.computeValues(values);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"moveEnd\",\n    value: function moveEnd(event) {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('pointer', 'change', this.move.bind(this));\n      bindFunction('pointer', 'leave', this.moveEnd.bind(this));\n    }\n  }]);\n\n  return MoveEngine;\n}(CoordinatesEngine);\n\nvar moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: function mouseOnly() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  }\n});\n\nvar ScrollEngine = /*#__PURE__*/function (_CoordinatesEngine3) {\n  _inherits(ScrollEngine, _CoordinatesEngine3);\n\n  var _super5 = _createSuper(ScrollEngine);\n\n  function ScrollEngine() {\n    var _this9;\n\n    _classCallCheck(this, ScrollEngine);\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _this9 = _super5.call.apply(_super5, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this9), \"ingKey\", 'scrolling');\n\n    return _this9;\n  }\n\n  _createClass(ScrollEngine, [{\n    key: \"scroll\",\n    value: function scroll(event) {\n      if (!this.state._active) this.start(event);\n      this.scrollChange(event);\n      this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));\n    }\n  }, {\n    key: \"scrollChange\",\n    value: function scrollChange(event) {\n      if (event.cancelable) event.preventDefault();\n      var state = this.state;\n      var values = scrollValues(event);\n      state._delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n      _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n      this.computeValues(values);\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"scrollEnd\",\n    value: function scrollEnd() {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute();\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('scroll', '', this.scroll.bind(this));\n    }\n  }]);\n\n  return ScrollEngine;\n}(CoordinatesEngine);\n\nvar scrollConfigResolver = coordinatesConfigResolver;\n\nvar WheelEngine = /*#__PURE__*/function (_CoordinatesEngine4) {\n  _inherits(WheelEngine, _CoordinatesEngine4);\n\n  var _super6 = _createSuper(WheelEngine);\n\n  function WheelEngine() {\n    var _this10;\n\n    _classCallCheck(this, WheelEngine);\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    _this10 = _super6.call.apply(_super6, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this10), \"ingKey\", 'wheeling');\n\n    return _this10;\n  }\n\n  _createClass(WheelEngine, [{\n    key: \"wheel\",\n    value: function wheel(event) {\n      if (!this.state._active) this.start(event);\n      this.wheelChange(event);\n      this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));\n    }\n  }, {\n    key: \"wheelChange\",\n    value: function wheelChange(event) {\n      var state = this.state;\n      state._delta = wheelValues(event);\n      _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);\n\n      var _state$overflow = _slicedToArray(state.overflow, 2),\n          ox = _state$overflow[0],\n          oy = _state$overflow[1];\n\n      var _state$_delta = _slicedToArray(state._delta, 2),\n          dx = _state$_delta[0],\n          dy = _state$_delta[1];\n\n      var _state$_direction = _slicedToArray(state._direction, 2),\n          dirx = _state$_direction[0],\n          diry = _state$_direction[1];\n\n      if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {\n        state._movement[0] = state._movementBound[0];\n      }\n\n      if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {\n        state._movement[1] = state._movementBound[1];\n      }\n\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"wheelEnd\",\n    value: function wheelEnd() {\n      if (!this.state._active) return;\n      this.state._active = false;\n      this.compute();\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('wheel', '', this.wheel.bind(this));\n    }\n  }]);\n\n  return WheelEngine;\n}(CoordinatesEngine);\n\nvar wheelConfigResolver = coordinatesConfigResolver;\n\nvar HoverEngine = /*#__PURE__*/function (_CoordinatesEngine5) {\n  _inherits(HoverEngine, _CoordinatesEngine5);\n\n  var _super7 = _createSuper(HoverEngine);\n\n  function HoverEngine() {\n    var _this11;\n\n    _classCallCheck(this, HoverEngine);\n\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n\n    _this11 = _super7.call.apply(_super7, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this11), \"ingKey\", 'hovering');\n\n    return _this11;\n  }\n\n  _createClass(HoverEngine, [{\n    key: \"enter\",\n    value: function enter(event) {\n      if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n      this.start(event);\n      this.computeValues(pointerValues(event));\n      this.compute(event);\n      this.emit();\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(event) {\n      if (this.config.mouseOnly && event.pointerType !== 'mouse') return;\n      var state = this.state;\n      if (!state._active) return;\n      state._active = false;\n      var values = pointerValues(event);\n      state._movement = state._delta = _maths_b2a210f4_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);\n      this.computeValues(values);\n      this.compute(event);\n      state.delta = state.movement;\n      this.emit();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(bindFunction) {\n      bindFunction('pointer', 'enter', this.enter.bind(this));\n      bindFunction('pointer', 'leave', this.leave.bind(this));\n    }\n  }]);\n\n  return HoverEngine;\n}(CoordinatesEngine);\n\nvar hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {\n  mouseOnly: function mouseOnly() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    return value;\n  }\n});\n\nvar EngineMap = new Map();\nvar ConfigResolverMap = new Map();\n\nfunction registerAction(action) {\n  EngineMap.set(action.key, action.engine);\n  ConfigResolverMap.set(action.key, action.resolver);\n}\n\nvar dragAction = {\n  key: 'drag',\n  engine: DragEngine,\n  resolver: dragConfigResolver\n};\nvar hoverAction = {\n  key: 'hover',\n  engine: HoverEngine,\n  resolver: hoverConfigResolver\n};\nvar moveAction = {\n  key: 'move',\n  engine: MoveEngine,\n  resolver: moveConfigResolver\n};\nvar pinchAction = {\n  key: 'pinch',\n  engine: PinchEngine,\n  resolver: pinchConfigResolver\n};\nvar scrollAction = {\n  key: 'scroll',\n  engine: ScrollEngine,\n  resolver: scrollConfigResolver\n};\nvar wheelAction = {\n  key: 'wheel',\n  engine: WheelEngine,\n  resolver: wheelConfigResolver\n};\n\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/@use-gesture/core/dist/actions-65020aef.esm.js?");

/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"V\": () => (/* binding */ V),\n/* harmony export */   \"c\": () => (/* binding */ computeRubberband),\n/* harmony export */   \"r\": () => (/* binding */ rubberbandIfOutOfBounds)\n/* harmony export */ });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction clamp(v, min, max) {\n  return Math.max(min, Math.min(v, max));\n}\n\nvar V = {\n  toVector: function toVector(v, fallback) {\n    if (v === undefined) v = fallback;\n    return Array.isArray(v) ? v : [v, v];\n  },\n  add: function add(v1, v2) {\n    return [v1[0] + v2[0], v1[1] + v2[1]];\n  },\n  sub: function sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n  },\n  addTo: function addTo(v1, v2) {\n    v1[0] += v2[0];\n    v1[1] += v2[1];\n  },\n  subTo: function subTo(v1, v2) {\n    v1[0] -= v2[0];\n    v1[1] -= v2[1];\n  }\n};\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max) {\n  var constant = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.15;\n  if (constant === 0) return clamp(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\n\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var _ref3 = _slicedToArray(_ref, 2),\n      Vx = _ref3[0],\n      Vy = _ref3[1];\n\n  var _ref4 = _slicedToArray(_ref2, 2),\n      Rx = _ref4[0],\n      Ry = _ref4[1];\n\n  var _bounds = _slicedToArray(bounds, 2),\n      _bounds$ = _slicedToArray(_bounds[0], 2),\n      X0 = _bounds$[0],\n      X1 = _bounds$[1],\n      _bounds$2 = _slicedToArray(_bounds[1], 2),\n      Y0 = _bounds$2[0],\n      Y1 = _bounds$2[1];\n\n  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];\n}\n\n\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/@use-gesture/core/dist/maths-b2a210f4.esm.js?");

/***/ }),

/***/ "./node_modules/scroll-into-view-if-needed/es/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/scroll-into-view-if-needed/es/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! compute-scroll-into-view */ \"./node_modules/compute-scroll-into-view/dist/index.module.js\");\n\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\n\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n\n  var canSmoothScroll = ('scrollBehavior' in document.body.style);\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n        top = _ref.top,\n        left = _ref.left;\n\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\n\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n\n  if (isOptionsObject(options)) {\n    return options;\n  }\n\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\n\nfunction scrollIntoView(target, options) {\n  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);\n\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(isTargetAttached ? (0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, options) : []);\n  }\n\n  if (!isTargetAttached) {\n    return;\n  }\n\n  var computeOptions = getOptions(options);\n  return defaultBehavior((0,compute_scroll_into_view__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, computeOptions), computeOptions.behavior);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (scrollIntoView);\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/scroll-into-view-if-needed/es/index.js?");

/***/ }),

/***/ "./node_modules/staged-components/index.js":
/*!*************************************************!*\
  !*** ./node_modules/staged-components/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.staged = void 0;\n\nvar react_1 = __importDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nfunction processNext(next) {\n  if (typeof next === 'function') {\n    return react_1[\"default\"].createElement(Stage, {\n      stage: next\n    });\n  } else {\n    return next;\n  }\n}\n\nfunction Stage(props) {\n  var next = props.stage();\n  return processNext(next);\n}\n\nfunction staged(stage) {\n  return function Staged(props, ref) {\n    var next = stage(props, ref);\n    return processNext(next);\n  };\n}\n\nexports.staged = staged;\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/staged-components/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://copy_password_plugin/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ })

}]);